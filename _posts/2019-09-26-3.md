---
layout: post
title: spring framework start
category: spring
tags:
  - content
  - spring
---

### spring keyword

- Inversion of Control
- Dependency Injection
- Aspect Oriented Programming
- Portable Service Abstraction

## Inversion of Control : 제어권은 개발자에게 없다.

IoC Container  
객체를 만들어 주며 Bean의 의존성도 관리해 준다.

- Application Context(interface)
- Bean Factory

```java
@Controller
public class Controller {
  @Autowired
  ApplicationContext applicationContext;
}
```

이렇게 직접 사용할일은 별로 없다.

## Bean : Sprign IoC가 관리하는 객체

### 등록법

### 1. Component Scanning

- Component
  - Configuration
  - Repository
  - Service
  - Controller
  - RestController

### 2. 직접 XML, java config 설정

※ 반드시 Bean만 의존성 주입을 해준다.

## Dependency Injection 의존성 주입

@Autowired @Inject는 <u>생성자</u> , <u>field</u> , <u> setter</u>에 붙일 수 있다.

#### ※ annotation없는데 Bean으로 만드는 경우는 어떠한 것인가

sprign Data JPA : interface를 상속받은 interface를 구현 하면

```java
@Controller
public class Controller {
  private Service service;
  private Repository repository;
  //costructor
  public Controller (Service service,Repository repository) {
    this.service = service;
    this.repository = repository;
  }
}
```

위와같이 생성자에 넣어준다면 `@Autowired`를 사용하지 않아도 되고 더욱 명확하다.

## AOP (Proxy Pattern)

흩어진 code를 한 곳으로 모으는 Programming 기법.

```java
@Transactional
try{
  // 여기가 실패하면
}catch(e){
  // 여기서 롤백
}
```

## SPA Portable Service Abstraction

= 잘 만든 interface.  
이식가능한 서비스 추상화.

- 확장성이 좋지 못한 code
- 기술에 특화 되어있는 code

### spring Trancaction

`Transactional` : transaction Aspect가 바뀌지 않음.

- PlatformTransactionManager(i)

### spring Cache (CacheManager)

`Cacheable` `CacheEvit` ...

### spring Web MVC

`@Controller` `@RequestMapping`...

servlet ? Reactive ... ?  
뭘쓰는지 코드만 봐선 알수가 없다.
